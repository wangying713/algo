# 排序

## 冒泡排序

### 解释

相邻的两个元素比较，当满足大小关系的时候，就交换他们，每经过一次排序，至少有一个元素会出现在应该出现的位置。例如第一次排序，那么最大的元素一定出现在数组的末端。

冒泡排序的操作是两个原子，比较操作和交换操作。

### 复杂度分析

**时间复杂度**

**有序度**
分析复杂度钱，先理解小有序度与逆有序度，有序度就是数组中有序数字的对数，例如 ```1, 8, 6, 3, 9``` 有序度为 ```(1,8), (1, 6), (1, 3), (1, 9), (8, 9), (6, 9), (3, 9) ``` 一共是 7对。 满有序度的对数为 ```n * (n-1) / 2 = 5 * (5-1) / 2 = 10``` 有序度的对数一共有10对。

**逆有序度**
逆有序度 = 满有序度 - 有序度，在上一个栗子中，逆有序度 = ```10 - 7 = 3 ``` 对。

**时间复杂度**
冒泡排序的操作有两个原子操作，即比较和交换，比较次数是确定不变的（优化除外），交换次数就是逆有序度，因此只要分析出逆有序度的最好情况和最坏情况就能确定最优与最坏情况的复杂度。

**最优情况**
最优情况是逆有序度为0，也就是说不需要交换。例如 ```1,2,3,4,5```的有序度为```10```，逆有序度为0, 0次交换。复杂度就是```O(n)```

**最坏情况**
与最优情况相反，交换次数为满有序度的次数。为 ```O(n的2次方)```。
了解时间复杂度前，先了解一下有序度与逆有序度，逆有序度 = 满有序度 - 有序度。

**平均情况**
当一组数据的有序度为0，逆有序度就等于```n*(n-1)/2```。取平均值就是 ```n*(n-1)/4```。比较次数一定比交换次数多。上限还是 ```O(n2)```。

**稳定性与原地排序**
由于是原地排序时间复杂度位  ```O(1)```，是常数级别的。
在排序的同时没有改变相同值的顺序，因此是稳定算法。

### 优化
当没有数据交换时，代表已经有序，没有必须再次比较下去了，直接跳出操作即可
每次排序之后都会有临界点，范围定在循环指定临界点。参考在代码实现上会更好理解。

## 代码实现
```go
func bubbleSort(arr []int) {
    var length = len(arr)
    for i := 0; i < length; i++ {
        // 标记是否交换位置
        var isSwap = false
        for j := 1; j < length-i; j++ {
            if arr[j-1] > arr[j] {
                // 交换位置
                var tmp = arr[j]
                arr[j] = arr[j-1]
                arr[j-1] = tmp

                isSwap = true
            }
        }

        // 如果没有交换位置，那么跳出结束
        if isSwap == false {
            break
        }
    }
}
```

## 插入排序

## 选择排序